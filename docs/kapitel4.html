<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />



<meta name="date" content="2024-06-17" />

<title>Kapitel 4</title>

<script src="site_libs/header-attrs-2.27/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}

.tocify-subheader {
  display: inline;
}
.tocify-subheader .tocify-item {
  font-size: 0.95em;
}

</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">DA2004 Programmersteknik</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Förord</a>
</li>
<li>
  <a href="kapitel1.html">1: Kom igång med Python</a>
</li>
<li>
  <a href="kapitel2.html">2: Grunder i Python-programmering</a>
</li>
<li>
  <a href="kapitel3.html">3: Listor och iteration</a>
</li>
<li>
  <a href="kapitel4.html">4: Uppslagstabeller, filhantering och mer om loopar</a>
</li>
<li>
  <a href="kapitel5.html">5: Felhantering, särfall, listomfattning och felsökning</a>
</li>
<li>
  <a href="kapitel6.html">6: Sekvenser och generatorer</a>
</li>
<li>
  <a href="kapitel7.html">7: Moduler, bibliotek och programstruktur</a>
</li>
<li>
  <a href="kapitel8.html">8: Funktionell programmering</a>
</li>
<li>
  <a href="kapitel9.html">9: Objektorientering 1: Klasser</a>
</li>
<li>
  <a href="kapitel10.html">10: Objektorientering 2: Arv</a>
</li>
<li>
  <a href="kapitel11.html">11: Objektorientering 3: Mer om arv</a>
</li>
<li>
  <a href="kapitel12.html">12: Defensiv programmering</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Kapitel 4</h1>
<h4 class="date">2024-06-17</h4>

</div>


<script src="https://cdn.datacamp.com/datacamp-light-latest.min.js"></script>
<p>En “datastruktur” är en typ för att samla data. Istället för att ha
ett tal i en <code>float</code> eller en sträng i en <code>str</code> så
håller en datastruktur reda på många olika data på ett logiskt sätt. Vi
har redan sett ett antal sätt i kursen, som till exempel listor. I det
här kapitlet ska vi titta på <em>uppslagstabeller</em> som har likheter
med listor men kan indexeras med andra typer än heltal.</p>
<p>Vi vill också kunna spara data till en fil på datorn eller läsa in
data från en fil. Vi ska i kapitlet även titta på hur detta kan göras.
Slutligen kommer vi även titta lite mer på vad man kan göra med loopar i
Python.</p>
<div id="uppslagstabeller" class="section level1" number="1">
<h1><span class="header-section-number">1</span> Uppslagstabeller</h1>
<p>Uppslagstabeller (eng. <em>dictionaries</em>) är en datastruktur som
blivit en arbetshäst för scriptspråk. De är enkla att använda och bra
till mycket. Uppslagstabellen är som en lista, men man indexerar med
<em>nycklar</em> (eng. <em>keys</em>) istället för med heltal. Man kan
tänka på en uppslagstabell som en mängd av nyckel-värde par (eng.
<em>key-value pairs</em>). I Python används typen <code>dict</code> för
uppslagstabeller.</p>
<p>Det finns två typiska sätt i Python att skapa en uppslagstabell. Till
exempel kan man skapa en uppslagstabell som har nycklarna
<code>'DA2004'</code> och <code>'MM2001'</code> med respektive värden
<code>7.5</code> och <code>30</code> genom:</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6ImhwMSA9IGRpY3QoREEyMDA0PTcuNSwgTU0yMDAxPTMwKVxuaHAyID0geydEQTIwMDQnOiA3LjUsICdNTTIwMDEnOiAzMH0ifQ==
</div>
<p>Båda sätten är identiska och <code>hp1 == hp2</code>. Lägg märke till
att första sättet har samma syntax som att anropa en funktion med
nyckelparametrarna <code>DA2004</code> och <code>MM2001</code>, medan
det andra sättet använder sig av en <em>sträng</em> för nyckeln och
värdet separerat med ett kolon.</p>
<p>För att komma åt ett värde används <code>[]</code>-syntax med
<em>nyckelvärdet</em>:</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6InByaW50KCdOdW1iZXIgb2YgRUNUUyBwb2ludHMgZm9yIERBMjAwNDonLCBocDFbJ0RBMjAwNCddKSJ9
</div>
<pre class="python"><code>Number of ECTS points for DA2004: 7.5</code></pre>
<p>Lägg märke till att själva nyckeln också kan vara en variabel. I både
<code>hp1</code> och <code>hp2</code> är nycklarna strängar, dvs av
typen <code>str</code>. Ett exempel som illustrerar denna poäng:</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6IkRBMjAwNCA9IDMzXG5NTTIwMDEgPSAnaGVsbG8nXG5ocDMgPSB7REEyMDA0OiA3LjUsIE1NMjAwMTogMzB9XG5wcmludCgnTnVtYmVyIG9mIEVDVFMgcG9pbnRzIGZvciBEQTIwMDQ6JywgaHAzW0RBMjAwNF0pXG5wcmludCgnTnVtYmVyIG9mIEVDVFMgcG9pbnRzIGZvciBEQTIwMDQ6JywgaHAzWzMzXSlcbnByaW50KCdOdW1iZXIgb2YgRUNUUyBwb2ludHMgZm9yIE1NMjAwMTonLCBocDNbTU0yMDAxXSlcbnByaW50KCdOdW1iZXIgb2YgRUNUUyBwb2ludHMgZm9yIE1NMjAwMTonLCBocDNbJ2hlbGxvJ10pIn0=
</div>
<pre class="python"><code>Number of ECTS points for DA2004: 7.5
Number of ECTS points for DA2004: 7.5
Number of ECTS points for MM2001: 30
Number of ECTS points for MM2001: 30</code></pre>
<p>Här har antingen värdet av till exempel <code>MM2001</code> använts
som nyckel direkt, eller så har identifieraren använts. Om man skulle
försöka använda sig av en <em>sträng</em> av <em>värdet</em> `‘MM2001’
här, så får man ett fel:</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6InByaW50KCdOdW1iZXIgb2YgRUNUUyBwb2ludHMgZm9yIE1NMjAwMTonLCBocDNbJ01NMjAwMSddKSJ9
</div>
<pre class="python"><code>KeyError: &#39;MM2001&#39;</code></pre>
<p>Det här har att göra med att alla objekt i Python som inte kan ändras
kan användas som nycklar. Uppslagstabeller implementeras med en teknik
som kallas hashtabeller och innebär att man konverterar nyckeln till ett
heltal (det “hashas”, vilket avser att man “hackar upp” och blandar
bytes till ett heltal) som används för uppslagning. Om nyckel kan
ändras, “muteras”, då finns det risk att man inte hittar tillbaka till
det man stoppat in i tabellen. Generellt gäller att
<em>icke-muterbara</em> värden, till exempel strängar, tal, tupler etc.,
kan användas som nycklar. Det här utesluter muterbara typer som till
exempel listor.</p>
<p>Använder man sig av <code>dict()</code> för att skapa en
uppslagstabell, så tolkas nyckelparametrarna alltid som strängar.</p>
<p>För mer detaljerad dokumentation av uppslagstabeller i Python se:</p>
<ul>
<li><a
href="https://docs.python.org/3/tutorial/datastructures.html#dictionaries"
class="uri">https://docs.python.org/3/tutorial/datastructures.html#dictionaries</a></li>
<li><a
href="https://docs.python.org/3/library/stdtypes.html#mapping-types-dict"
class="uri">https://docs.python.org/3/library/stdtypes.html#mapping-types-dict</a></li>
</ul>
<div id="viktiga-egenskaper" class="section level2" number="1.1">
<h2><span class="header-section-number">1.1</span> Viktiga
egenskaper</h2>
<ul>
<li>En uppslagning är billig (dvs snabb).</li>
<li>Det är enkelt att ändra innehåll.</li>
<li>Uppslagstabeller är enkla att iterera över (men du får inte ändra i
en uppslagstabell under iteration).</li>
</ul>
</div>
<div id="andra-namn" class="section level2" number="1.2">
<h2><span class="header-section-number">1.2</span> Andra namn</h2>
<ul>
<li>Hashtabell</li>
<li>Hash map</li>
</ul>
<p>I “traditionella” språk (C, C++, Java, m.fl.) har de inte samma
särställning som i scriptspråken. Scriptspråken har gjort
uppslagstabeller lättanvända.</p>
</div>
<div id="fler-exempel" class="section level2" number="1.3">
<h2><span class="header-section-number">1.3</span> Fler exempel</h2>
<p>Tomma uppslagstabellen kan skrivas <code>{}</code>, detta är
syntaktiskt socker för <code>dict()</code>.</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6ImVtcHR5ID0ge31cbnByaW50KGVtcHR5KVxucHJpbnQoZGljdCgpKSJ9
</div>
<pre class="python"><code>{}
{}</code></pre>
<p>Som vi noterat ovan kan man skapa uppslagstabeller på följande
sätt:</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6InRlc3QxID0geydob3BwJzogNDEyNywgJ2Zvbyc6IDQwOTgsICdoZWonOiA0MTM5LCAxMjogJ2hlaid9XG50ZXN0MiA9IGRpY3QoWygnaGVqJywgNDEzOSksICgnaG9wcCcsIDQxMjcpLCAoJ2ZvbycsIDQwOTgpXSlcblxucHJpbnQodGVzdDEpXG5wcmludCh0ZXN0MikifQ==
</div>
<pre class="python"><code>{&#39;hopp&#39;: 4127, &#39;foo&#39;: 4098, &#39;hej&#39;: 4139, 12: &#39;hej&#39;}
{&#39;hej&#39;: 4139, &#39;hopp&#39;: 4127, &#39;foo&#39;: 4098}</code></pre>
<p>Observera att nycklar och värden inte behöver vara av samma typ!</p>
<p>Man kan uppdatera uppslagstabeller på liknande sätt som listor, och
lägga till nya nyckel-värde par genom <code>[-]</code> och ta bort med
<code class="python">del</code>:</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6ImhwID0ge31cbmhwWydEQTIwMDQnXSA9IDdcbnByaW50KGhwWydEQTIwMDQnXSlcblxuaHBbJ0RBMjAwNCddICs9IDAuNVxucHJpbnQoaHBbJ0RBMjAwNCddKVxuXG5ocFsnTU0yMDAxJ10gPSAzMFxuaHBbJ1VHMTAwMSddID0gMVxucHJpbnQoaHApXG5cbmRlbCBocFsnVUcxMDAxJ11cbnByaW50KGhwKSJ9
</div>
<pre class="python"><code>7
7.5
{&#39;DA2004&#39;: 7.5, &#39;MM2001&#39;: 30, &#39;UG1001&#39;: 1}
{&#39;DA2004&#39;: 7.5, &#39;MM2001&#39;: 30}</code></pre>
</div>
<div id="iterera-över-uppslagstabeller" class="section level2"
number="1.4">
<h2><span class="header-section-number">1.4</span> Iterera över
uppslagstabeller</h2>
<p>Vi kan använda <code class="python">for</code> för att iterera över
nycklarna:</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6ImZvciBrZXkgaW4gaHA6XG4gICAgcHJpbnQoa2V5KSJ9
</div>
<pre class="python"><code>DA2004
MM2001</code></pre>
<p>Vi kan även använda <code>.keys()</code>:</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6ImZvciBrZXkgaW4gaHAua2V5cygpOlxuICAgIHByaW50KGtleSkifQ==
</div>
<pre class="python"><code>DA2004
MM2001</code></pre>
<p>och <code>.values()</code>:</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6ImZvciB2YWwgaW4gaHAudmFsdWVzKCk6XG4gICAgcHJpbnQodmFsKSJ9
</div>
<pre class="python"><code>7.5
30</code></pre>
<p>Vi kan även extrahera alla par av nycklar och värden med
<code>.items()</code>:</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6ImZvciBrZXksIHZhbCBpbiBocC5pdGVtcygpOlxuICAgIHByaW50KCdOdW1iZXIgb2YgRUNUUyBwb2ludHMgZm9yICcgKyBrZXkgKyAnOiAnICsgc3RyKHZhbCkpIn0=
</div>
<pre class="python"><code>Number of ECTS points for DA2004: 7.5
Number of ECTS points for MM2001: 30</code></pre>
<p>Alla dessa tre funktioner returnerar itererbara objekt med element
som består av antingen nycklar, värden eller tupler med
nyckel-värde-par.</p>
</div>
<div id="funktioner-för-uppslagstabeller" class="section level2"
number="1.5">
<h2><span class="header-section-number">1.5</span> Funktioner för
uppslagstabeller</h2>
<p>Vi kan även manipulera uppslagstabeller med liknande funktioner som
för listor:</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6InByaW50KGxlbihocCkpXG5ocFsnZm9vJ10gPSAyMC4wXG5wcmludChsZW4oaHApKVxuXG5wcmludCgnREEyMDA0JyBpbiBocClcbnByaW50KCcyMC4wJyBpbiBocCkifQ==
</div>
<pre class="python"><code>2
3
True
False</code></pre>
<p>En till användbar funktion är <code>.get()</code>, som tar två
argument: nyckelvärdet och ett värde som returneras om nyckeln
<em>inte</em> finns i uppslagstabellen. Om nyckeln finns, returneras
värdet som hör till nyckeln.</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6InByaW50KGhwLmdldCgnREEyMDA0JywgNDIpKSAjIGtleSBleGlzdHNcbnByaW50KGhwLmdldCgnYmFyJywgNDIpKSAjIGtleSBkb2VzIG5vdCBleGlzdCJ9
</div>
<pre class="python"><code>7.5
42</code></pre>
</div>
</div>
<div id="filhantering" class="section level1" number="2">
<h1><span class="header-section-number">2</span> Filhantering</h1>
<p>Filer innehåller information som ligger på hårddisken, till exempel
textfiler, bilder eller filmer, etc. Du kommer åt filer genom att
interagera med operativsystemet. Detta kan göras direkt från Python.</p>
<div id="läsa-från-filer" class="section level2" number="2.1">
<h2><span class="header-section-number">2.1</span> Läsa från filer</h2>
För att till exempel läsa från en fil <code>data.txt</code> skaffar vi
först ett “handtag” (eng. <em>handle</em>). Det gör man med
<code>open()</code>, som tar ett filnamn som obligatoriskt argument.
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6ImggPSBvcGVuKCdkYXRhLnR4dCcpIn0=
</div>
<p>Ibland lägger man till ett andra argument med strängen “r” som
markerar att man tänker läsa (<em>read</em>) filen.</p>
<pre class="python"><code>h = open(&#39;data.txt&#39;, &#39;r&#39;)   # &#39;r&#39; för &quot;read&quot;</code></pre>
<p>För att läsa in hela filens innehåll till en sträng skriver vi
sedan:</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6ImgucmVhZCgpICMgd2hvbGUgZmlsZSBpbiBzdHJpbmcifQ==
</div>
<p>eller en lista med strängar där varje list-element är en rad från
filen:</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6ImgucmVhZGxpbmVzKCkgIyB3aG9sZSBmaWxlIGFzIGxpc3Qgb2Ygc3RyaW5ncyJ9
</div>
<p>Detta funkar inte bra i många fall med stora filer. Det blir problem
om man läser in en fil som är större än datorns RAM-minne.</p>
<p>För att bara läsa in en rad från <code>h</code> använder vi:</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6ImgucmVhZGxpbmUoKSJ9
</div>
<p>Notera att innehållet i en fil läses <em>en gång</em>, så har vi
redan använt oss av <code>read</code> eller <code>readlines</code> så
kommer <code>readline</code> att inte göra något, eftersom
handtaget/filpekaren redan har kommit till slutet av filen.</p>
</div>
<div id="skriva-till-filer" class="section level2" number="2.2">
<h2><span class="header-section-number">2.2</span> Skriva till
filer</h2>
Om vi vill skriva till en fil <code>out_data.txt</code> måste återigen
använda <code>open</code> för att skapa ett filhandtag, men nu måste man
skicka med strängen “w” som andra argument (<code>w</code> för
<em>write</em>) för att indikera att man tänker just skriva till filen.
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6Im91dHB1dCA9IG9wZW4oJ291dF9kYXRhLnR4dCcsICd3JykifQ==
</div>
<p>Detta <em>skapar</em> eller <em>tömmer</em> filen
<code>out_data.txt</code>. <strong>Varning:</strong> Var försiktig då
allt i filen <code>out_data.txt</code> kommer att försvinna om den redan
finns! Om vi vill skriva till <code>output</code> (dvs till filen
<code>out_data.txt</code>) så använder man idag nyckel-parametern
<code>file</code> till <code>print</code>:</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6InByaW50KCdUaGlzIGlzIG15IGZpcnN0IGxpbmUnLCBmaWxlPW91dHB1dClcbnByaW50KCdcXG4nLCBmaWxlPW91dHB1dCkgIyBzdGFydCBhIG5ldyBsaW5lXG5wcmludCgnVGhpcyBpcyBteSBzZWNvbmQgbGluZScsIGZpbGU9b3V0cHV0KSJ9
</div>
I äldre kod kan du komma att se ett annat skrivsätt:
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6Im91dHB1dC53cml0ZSgnVGhpcyBpcyBteSBmaXJzdCBsaW5lJylcbm91dHB1dC53cml0ZSgnXFxuJykgIyBzdGFydCBhIG5ldyBsaW5lXG5vdXRwdXQud3JpdGUoJ1RoaXMgaXMgbXkgc2Vjb25kIGxpbmUnKSJ9
</div>
<p>Här används <code>write</code> som är en funktion som är associerad
med en öppnad fil. Det här skrivsättet används också i många andra
programmeringsspråk.</p>
<p>Observera att det inte är möjligt att skriva till en fil som är
öppnad för läsning, och inte heller tvärtom.</p>
</div>
<div id="stänga-filer" class="section level2" number="2.3">
<h2><span class="header-section-number">2.3</span> Stänga filer</h2>
<p>När vi är klara med en fil bör vi stänga den:</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6ImguY2xvc2UoKVxub3V0cHV0LmNsb3NlKCkifQ==
</div>
<p>Det är viktigt att stänga filer:</p>
<ul>
<li>Antalet öppnade filer är begränsat i ett operativsystem – slösa inte
med dem!</li>
<li>Ett annat program kan vilja skriva till öppnad fil – släpp den så
annat program inte behöver vänta!</li>
<li>Du kan förlora data om du inte stängt filen.</li>
</ul>
<p>När ett program avslutas så stängs öppna filer automatiskt, men det
anses ändå vara god programmering att tydligt stänga en fil.</p>
</div>
<div id="ett-exempel" class="section level2" number="2.4">
<h2><span class="header-section-number">2.4</span> Ett exempel</h2>
<p>Tänk dig en fil <code>people.txt</code> med komma-separerad
information: <code>efternamn,förnamn,födelseår</code>.</p>
<pre><code>Svensson,Lisa,1815
Olsson,Erik,1901
Mörtberg,Anders,1986</code></pre>
<p>Följande program skapar en fil <code>modern.txt</code> med alla från
1900-talet:</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6ImhfaW4gPSBvcGVuKCdwZW9wbGUudHh0JywgJ3InKVxuaF9vdXQgPSBvcGVuKCdtb2Rlcm4udHh0JywgJ3cnKVxuZm9yIG4gaW4gaF9pbjogICAgIyBsb29wIHRocm91Z2ggdGhlIGZpbGUsIHJvdyBieSByb3dcbiAgICBsbmFtZSwgZm5hbWUsIHllYXIgPSBuLnNwbGl0KCcsJylcbiAgICBpZiBpbnQoeWVhcikgPiAxOTAwOlxuICAgICAgICBoX291dC53cml0ZShmbmFtZSArICcgJyArIGxuYW1lICsgJ1xcbicpXG5oX291dC5jbG9zZSgpXG5oX2luLmNsb3NlKCkifQ==
</div>
<p>Öppnar vi nu filen <code>modern.txt</code> så kommer den
innehålla</p>
<pre><code>Erik Olsson
Anders Mörtberg</code></pre>
</div>
<div id="ett-praktiskt-idiom-with-open" class="section level2"
number="2.5">
<h2><span class="header-section-number">2.5</span> Ett praktiskt idiom:
<code>with open</code></h2>
<p>Python-konstruktionen <code class="python">with open</code> har
blivit populär och anses idag vara idiomatisk för att arbeta med filer.
Anledningen är att idiomet förbättrar läsbarheten för program och
uppmuntrar till god kodstruktur.</p>
<p>Här är ett minimalt exempel:</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6IndpdGggb3BlbigndXQudHh0JywgJ3cnKSBhcyBvdXQ6XG4gICAgIHByaW50KCdoZWogaG9wcCcsIGZpbGU9b3V0KSJ9
</div>
<p>Detta motsvarar</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6Im91dCA9IG9wZW4oJ3V0LnR4dCcsICd3JylcbnByaW50KCdoZWogaG9wcCcsIGZpbGU9b3V0KVxub3V0LmNsb3NlKCkifQ==
</div>
<p>Det finns flera fördelar med att använda <code>with open</code>:</p>
<ul>
<li>Ditt program blir med lättläst.</li>
<li>Det uppmuntrar till god kodstruktur.</li>
<li>Det anses underlätta felhantering.</li>
<li>Filer stängs när man lämnar <code>with</code>-blocket</li>
</ul>
<p>I Python kallas <code>with</code> för en <em>kontexthanterare</em>
(eng: <em>context handler</em>) och kan tillämpas även för annat än
filer.</p>
<p>Exemplet ovan kan skrivas om med <code>with</code> på följande
sätt:</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6IndpdGggb3BlbigncGVvcGxlLnR4dCcsICdyJykgYXMgaF9pbiwgb3BlbignbW9kZXJuLnR4dCcsICd3JykgYXMgaF9vdXQ6XG4gICAgZm9yIG4gaW4gaF9pbjpcbiAgICAgICAgbG5hbWUsZm5hbWUseWVhciA9IG4uc3BsaXQoJywnKVxuICAgICAgICBpZiBpbnQoeWVhcikgPiAxOTAwOlxuICAgICAgICAgICAgcHJpbnQoZid7Zm5hbWV9IHtsbmFtZX0nLCBmaWxlPWhfb3V0KVx0In0=
</div>
</div>
<div id="att-tänka-på-kring-filhantering" class="section level2"
number="2.6">
<h2><span class="header-section-number">2.6</span> Att tänka på kring
filhantering</h2>
<ul>
<li>Läsa och skriva filer är långsamt.
<ul>
<li>Undvik att läsa en fil två gånger.</li>
<li>Använd filer som mellanlagring bara om du måste.</li>
</ul></li>
<li>En del filer är stora. Undvik därför att läsa in allt om det ej
behövs. Att läsa in 10 GB data till en dator med 8 GB RAM kan vara
katastrofalt för en beräknings hastighet, och om man ändå behandlar data
radvis så kan det gå mycket snabbare att läsa in data rad för rad.</li>
<li>Undvik att hårdkoda sökvägar. Du ska inte anta att andra användare
har filerna på samma plats som du.</li>
<li>Tillfälliga filer bör ha unika och tillfälliga namn.
<ul>
<li>Använd modulen <code>tempfile</code> (<a
href="https://docs.python.org/3/library/tempfile.html">https://docs.python.org/3/library/tempfile.html</a>
för säkerhet och bekvämlighet!</li>
</ul></li>
</ul>
</div>
<div id="tre-speciella-filer" class="section level2" number="2.7">
<h2><span class="header-section-number">2.7</span> Tre speciella
filer</h2>
<p>På Unix-system (det inkluderar olika Linux-varianter och MacOS) så
finns alltid tre filer öppna, och det har förts över till PC-system
också:</p>
<ul>
<li>sys.stdin</li>
<li>sys.stdout</li>
<li>sys.stderr</li>
</ul>
<p>Du kommer åt dessa om du har använt instruktionen
<code>import sys</code> som betyder “läs in modulen <code>sys</code>”
(läs mer om <code>import</code> i kapitel 7!) .</p>
<p>Det som är speciellt med dessa filer är att de inte är knutna till
någon slags fil på hårddisken (eller motsvarande), åtminstone inte utan
annan programmatisk instruktion. I vanliga fall är
<code>sys.stdin</code> knutet till ditt tangentbord och om du läser från
den filen så är det som att läsa av tecken vartefter du skriver dem.
Filerna <code>sys.stdout</code> och <code>sys.stderr</code> kan man se
som knutna till den terminal eller utdata-enhet som din Python-tolk
använder. Dessa två kan styras om, till exempel till en datafil, och det
är grunden till att man har <em>två</em> utdata-filer: om du skriver
varningar och felmeddelanden till <code>sys.stderr</code> så beblandas
inte dessa med utdata. Du får helt enkelt två skilda kanaler för data
och användarkommunikation.</p>
<p>Dessa tre filer är ett arv från 70-talets datorer och hör till
Unix-traditionen, men är än idag mycket användbart.</p>
</div>
</div>
<div id="mer-om-loopar-nästling" class="section level1" number="3">
<h1><span class="header-section-number">3</span> Mer om loopar:
nästling</h1>
<p>Syntaxen för en <code class="python">for</code>-loop bygger på att
den indragna “kroppen” på loopen har en eller flera satser. Man kan
förstås använda <em>fler</em> loopar:</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6ImZvciBpIGluIHJhbmdlKDMpOlxuICAgIGZvciBqIGluIHJhbmdlKDMpOlxuICAgICAgICBwcmludChpICogaikifQ==
</div>
<pre class="python"><code>0
0
0
0
1
2
0
2
4</code></pre>
<p>Märk att man ökar indraget för varje loop man gör. Indraget är
viktigt för att avgöra strukturen på programmet och hur det exekveras!
Ett exempel:</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6InByaW50KCctLS0tLS0tLS0nKVxuZm9yIGkgaW4gcmFuZ2UoMSw0KTpcbiAgICBmb3IgaiBpbiByYW5nZSgxLDQpOlxuICAgICAgICBwcmludChpLCBqLCBpICogaiwgc2VwPScgICAnKVxuICAgIHByaW50KCctLS0tLS0tLS0nKSJ9
</div>
<pre class="python"><code>---------
1   1   1
1   2   2
1   3   3
---------
2   1   2
2   2   4
2   3   6
---------
3   1   3
3   2   6
3   3   9
---------</code></pre>
<p>Notera att <code>print('---------')</code> endast körs en gång i den
yttre loopen. Vad hade hänt om vi istället haft den lika långt indragen
som <code>print(i, j, i * j, sep=' ')</code>?</p>
<p>Vi kan även kontrollera att endast beräkna jämna produkter med hjälp
av villkorssatser i looparna. Notera indenteringsnivån på de två olika
<code class="python">if</code>-satserna.</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6ImZvciBpIGluIHJhbmdlKDEsOCk6XG4gICAgaWYgaSAlIDIgPT0gMTpcbiAgICAgICAgY29udGludWVcbiAgICBmb3IgaiBpbiByYW5nZSgxLDgpOlxuICAgICAgICBpZiBqICUgMiA9PSAxOlxuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgcHJpbnQoaSAqIGopIn0=
</div>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6IjRcbjhcbjEyXG44XG4xNlxuMjRcbjEyXG4yNFxuMzYifQ==
</div>
</div>
<div id="algoritmiskt-tänkande" class="section level1" number="4">
<h1><span class="header-section-number">4</span> Algoritmiskt
tänkande</h1>
<p>När man lär sig programmering är en av de stora utmaningarna att
skapa sig en djup förståelse för datorn och programmeringsspråket, för
hur annars ska man veta vad man ska instruera datorn?</p>
<p>Språket Python är ett <em>högnivåspråk</em>, vilket innebär att
datorns tekniska detaljer i stor utsträckning abstraherats bort. Det kan
hjälpa att känna till vissa tekniska detaljer, se till exempel avsnittet
om <em>datarepresentation</em>, men i Python kan du komma långt ändå och
väsentligen låtsas som att du arbetar i en abstrakt och matematisk miljö
utan större tanke på hur din dator faktiskt fungerar.</p>
<p>Man kommer däremot inte ifrån det <em>algoritmiska tänkandet</em>:
att förstå hur man går från problembeskrivning till en lösning i form av
kod. Detta kan vara utmanande eftersom vi till vardags inte är så
noggranna med att beskriva hur man gör saker. När du kommunicerar med
andra om vad som ska göras i ett projekt eller uppdrag så är det mycket
som lämnas outtalat. Människor delar så mycket erfarenhet och
bakomliggande kunskap att alla detaljer inte behöver kommuniceras. Du
och din dator delar däremot inte mycket erfarenheter; för att få datorn
att göra det du vill måste du förklara dig in i minsta detalj.</p>
<div id="recept-är-inte-algoritmer" class="section level2" number="4.1">
<h2><span class="header-section-number">4.1</span> Recept är inte
algoritmer</h2>
<p></p>
<p>Recept brukar användas som en analogi för algoritmer och används
ibland för att illustrera algoritmiskt tänkande. Analogin är bra som
första förklaring av vad en algoritm är, men den kan också leda fel
eftersom recept bygger på mycket bakomliggande kunskap. Om du har lärt
ut matlagning till ett barn så har du nog märkt att det krävs lite mer
än att bara läsa receptet.</p>
<p>Ta till exempel uppgiften att tillaga pannkakor. Här är ett recept
(där första delen om ingredienser är borttagen) som de flesta av oss kan
följa utan problem.</p>
<ol style="list-style-type: decimal">
<li>Vispa ut vetemjölet i hälften av mjölken till en slät smet.</li>
<li>Vispa i resterande mjölk, ägg och salt.</li>
<li>Smält smör i stekpannan och häll ner i smeten.</li>
<li>Grädda tunna pannkakor i stekpannan. Circa 1 dl smet per lagg är
lagom.</li>
</ol>
<p>Redan i första punkten är det en massa detaljer som saknas. Ska jag
vispa i mjölet innan det hamnar i mjölken, eller är det bättre att dumpa
all mjöl i mjölken och sedan börja vispa? Vilket redskap bör användas
för vispningen? Och var ska vi arbeta? Man kan ju tänka sig att lägga
mjölet på bänken och blanda ner mjölken, men det verkar opraktiskt. Ska
man kanske använda mjölkförpackningen? Nja, det är nog bättre att ta
fram en ren bunke att arbeta i, men hur stor bör den vara?</p>
<p>Låt oss försöka förbättra första punkten så att receptet blir mer
algoritmiskt:</p>
<ol style="list-style-type: decimal">
<li>Blanda vetemjöl och mjölk så här:
<ol style="list-style-type: lower-alpha">
<li>Ta fram en bunke som har plats för 2 liter och häll i hälften av
mjölken.</li>
<li>Ta fram en visp.</li>
<li>Häll i mjölet, en matsked i taget, och vispa 20 sekunder mellan
varje matsked.</li>
</ol></li>
<li>Vispa i resterande mjölk, ägg och salt.</li>
<li>Smält smör i en stekpanna och häll ner i smeten.</li>
<li>Grädda tunna pannkakor i stekpannan. Circa 1 dl smet per lagg är
lagom.</li>
</ol>
<p>Det som åstadkommits är att en bedömning plockats bort (vad är en
“slät smet”?) och detaljeringsgraden har ökat, förhoppningsvis så att
viss tvetydighet har försvunnit. Skulle en sjuåring kunna följa steg
1?</p>
<p>Punkt 2 och 3 kan göras mer algoritmiska på liknande sätt, men lägg
märke till att punkt 4 har lite större utmaningar. Dels presenteras
uppgifterna i fel ordning (smeten måste ju hällas i pannan för att kunna
gräddas!), dels lämnas bedömningar till läsaren. Istället för att
föreslå 1 dl smet så bör vi noggrant förklara “häll i smet tills att
hela stekpannan täcks av ett tunt lager, men inte mer, eller smeten tar
slut.” Det sista villkoret hanterar att smeten sällan räcker till en
täcka stekpannans yta för sista pannkakan. Vi måste också förklara att
stekpannan ska vara varm (hur varm?), det behövs en stekspade, smeten
gräddas tills att undersidan blivit brunaktig och då vänder man och
gräddar andra sidan. Och vad innebär “brunaktig” egentligen?</p>
<p>Som du ser blir det mycket att skriva och detaljeringsgraden kan
snabbt bli lite frustrerande, men det kan vara vad som krävs för att
beskriva för en robot hur man gräddar pannkakor på “traditionellt
sätt”.</p>
</div>
<div id="top-down-down-up-och-att-göra-rätt" class="section level2"
number="4.2">
<h2><span class="header-section-number">4.2</span> <em>Top-down</em>,
<em>down-up</em>, och att göra rätt</h2>
<p>När vi förbättrade pannkaksreceptet så började vi med en ganska grov
beskrivning av vad som ska göras och förfinade första punkten. Det är
ett vanligt arbetssätt, särskilt när man är lite osäker på vad som ska
åstadkommas, och kallas för att arbeta uppifrån och ner, eller
<em>top-down</em>. Tanken är att stegvis bryta ner en uppgift i mindre
delar, tills att man når en nivå där det går att formulera kod för att
lösa deluppgiften.</p>
<p>Den motsatta ansatsen är att arbeta nerifrån och upp,
<em>bottom-up</em>, genom att identifiera användbar kod som det sedan
går att komponera ihop en större helhet med. Om man ska använda
pannkaksexemplet så kan man till exempel säga “jag vet hur man blandar
mjöl och mjölk, och det kommer ju behövas, så jag började koda den
deluppgiften.”</p>
<p>Du behöver inte välja mellan top-down och bottom-up, båda ansatserna
är användbara, och det viktiga är att arbeta med uppgiften. Du ska inte
ha förväntningen att man funderar på problemet, ser lösningen, och sen
skriver den kod som behövs. Så kan det vara ibland, åtminstone för en
erfaren programmerare, men det är inget fel att experimentera sig fram
och leta lösningar. Kom dock ihåg att skriven kod både kan och bör
modifieras efter behov. Nybörjare kan vara nöjda över att skriven kod
fungerar och undviker därför ibland att göra ändringar, men det innebär
ofta att man skjuter upp problemen och hamnar i svårare problem senare.
Det är lätt hänt att göra ett lite olämpligt designval och när det
upptäcks så bör man rätta misstaget. Det kan innebära att revidera sin
kod om och om igen. En av de viktigaste insikterna sen programmeringens
barndom är just att vi alla gör fel, oavsett hur väl man studerat en
uppgift och hur noggrant man planerat, och att det är bra att revidera
kod.</p>
<p>Ett annat trivialt faktum, som ändå missas ibland, är att det är
avgörande att förstå uppgiften. Det är, till exempel, lätt hänt att
uppdragsgivare och programmerare menar helt olika saker när en uppgift
diskuteras och oavsett hur snyggt programmeraren löser uppgiften (enligt
sin egen definition) kommer uppdragsgivaren att vara missnöjd. För att
återkomma till pannkaksexemplet så avser antagligen en uppdragsgivare
med amerikansk bakgrund inte samma sak med ordet “pancake” som en svensk
programmerare som kanske översätter till “pannkaka”. Det ligger långt
utanför den här kursen att lösa den utmaningen, men det är värt att
påpeka att även om du programmerar för egen del så kan du upptäcka att
det finns fler aspekter på en uppgift än du förstått från början.</p>
</div>
<div id="arbeta-med-uppgiften" class="section level2" number="4.3">
<h2><span class="header-section-number">4.3</span> Arbeta med
uppgiften!</h2>
<p>Några saker att tänka på, som kan uppfattas som triviala, men är
värdefulla att gå igenom, särskilt när man jobbar tillsammans med
andra:</p>
<ol style="list-style-type: decimal">
<li>Vad är indata till beräkningen? Till exempel, om du vill räkna
antalet ord i en text, hur är texten representerad? Den kanske ges som
en enda lång sträng? Eller kanske som en lista av strängar, där varje
sträng är en mening? Det är också bra att gå igenom lite extremfall. För
exemplet med att räkna ord är det bra att veta om kan texten vara tom,
det vill säga ha längd noll, eller finns det alltid minst ett ord? Om vi
går tillbaka till pannkaksalgoritmen, vet vi alltid att vi har
tillräckligt med ingredienser? Det vore kanske bra att anpassa receptet
efter hur många ägg man faktiskt har?</li>
<li>Hur ska resultatet se ut? I allmänhet vill vi skriva funktioner som
löser uppgifter, se kapitlet om <em>programstruktur</em>, och då ska man
utgå ifrån att funktionen ska returnera ett värde, men värdet kan bestå
av mycket information. Om du skriver en funktion som räknar antalet ord
i en text så kan det räcka med ett heltal som svar, men kanske är det
mer användbart att returnera en uppslagstabell som associerar ord med
ett heltal som beskriver hur många gånger det återkommer i texten?</li>
</ol>
<p>Det vi pratar om här är alltså start- och slutpunkt för en beräkning.
Men hur reder man ut det som kommer däremellan? Det är där själva
algoritmen ligger och det är inte alls självklart att den är lätt att
komma på. Vissa algoritmiska uppgifter är helt enkelt mycket svåra att
förstå och hitta lösningar på. I den här kursen är uppgifterna relativt
enkla, i den meningen att gymnasiekunskaper i matematik är tillräcklig
förberedelse. Oavsett svårighetsgrad så finns det sätt att arbeta sig
fram till en algoritm.</p>
<p>Det går att arbeta sig fram till algoritmer och de behöver inte alls
vara komplicerade för att lösa problem som är svåra att beskriva. Här är
några enkla tips för att komma framåt.</p>
<ul>
<li>Skapa små exempel. Dessa exempel kan vara bra för att experimentera
med när man vill komma på hur en algoritm ska se ut, och de kan vara
användbara när man vill testa sin kod.</li>
<li>Hur löser du <em>egentligen</em> en uppgift i huvudet? Vissa saker,
som addition, är vi så duktiga på att vi slutat tänka på vilka steg man
tar. En noggrann genomgång av de steg som du är bekväm med kan ge dig
lösningen.</li>
<li>Hur skulle du lösa uppgiften med penna och papper? Prova dig
fram!</li>
</ul>
<p>Just att arbeta med uppgiften är viktigt för att förstå problemet och
det kan vara kontraproduktivt att börja skriva kod med en gång: om du
inte förstår problemet så kommer din kod sannolikt vara fel. Å andra
sidan kan kodning vara ett sätt att upptäcka att man inte förstått
problemet.</p>
<p>Slutligen, se också till att förstå den kod du själv skriver. Man ska
inte önska sig fram till fungerande kod. Om du tänker “den här
funktionen borde ge mig svaret” eller “jag tror det här fungerar” så ska
du bromsa upp: ord som “borde” och “tror” är varningssignaler. Du ska
<em>veta</em> att koden fungerar eller åtmistone ha god skäl för att tro
att den fungerar. Om det känns skakigt så ska du helt enkelt testa.
Verifiera att funktioner gör det du tror de gör. Resonera för dig själv
om vad som borde hända i din kod. Förutom att du fastställer vad som
fungerar och inte fungerar så är det ett bra sätt att lära sig
programmering.</p>
</div>
</div>
<div id="representation-av-data" class="section level1" number="5">
<h1><span class="header-section-number">5</span> Representation av
data</h1>
<p>Ofta behöver man inte fundera på hur data lagras i en dator. När man
jobbar med till exempel heltal så räcker det att ha en abstrakt bild av
att tal lagras som nollor och ettor, för vi kan ju lätt se hur man kan
skriva <code>x = 7</code> och på olika sätt använda att heltalet 7
“finns” i <code>x</code>. Reglerna för hur nollor och ettor bildar
heltal kallas <em>heltalsrepresentation</em> och är idag standardiserat
(men Python avviker, se senare kapitel).</p>
<p>De inbyggda typerna i Python (och andra programmeringsspråk) är lätta
att använda utan att bry sig om deras representation, men för mer
problemspecifika data (tex personers adresser) och abstrakta idéer (som
polynom och andra matematiska begrepp) måste programmeraren tänka efter
och hitta sätt att använda språkets datastrukturer och andra finesser
för att hitta en lämplig <em>datarepresentation</em>. I det här kapitlet
diskuterar vi några exempel på hur man kan arbeta med
datarepresentation.</p>
<div id="lärandemål" class="section level2" number="5.1">
<h2><span class="header-section-number">5.1</span> Lärandemål</h2>
<ul>
<li>Representation av heltal, flyttal, strängar, och boolska värden</li>
<li>Andra data
<ul>
<li>Hur ska man lagra koordinater?</li>
<li>Hur kan man lagra polynom?</li>
<li>Lagring av datum och tid</li>
</ul></li>
</ul>
</div>
<div id="primitiva-datatyper" class="section level2" number="5.2">
<h2><span class="header-section-number">5.2</span> Primitiva
datatyper</h2>
<p>Många data representeras på ett rättframt sätt i programmeringsspråk
eftersom det finns inbyggda typer för dem. De mest grundläggande typerna
brukar kallas <em>primitiva datatyper</em> och i Python är det
<code>bool</code>, <code>int</code>, <code>float</code>,
<code>complex</code>, och <code>str</code>. Olika språk har olika
primitiva datatyper: i språket C är <code>char</code> en datatyp som
representerar ett tecken i exakt en byte, och strängar är (ungefär)
listor av <code>char</code>-värden. Python gör tvärtom, eftersom även
ett enskilt tecken ska lagras i en <code>str</code>.</p>
<p>Listor och uppslagstabeller kallas <em>sammansatta datatyper</em>,
eftersom de i någon mening består av primitiva datatyper.</p>
</div>
<div id="datastrukturer" class="section level2" number="5.3">
<h2><span class="header-section-number">5.3</span> Datastrukturer</h2>
<p>En datastruktur är en konstruktion som kan samla flera primitiva
datatyper till en enhet. Du har redan stött på listor och
uppslagstabeller som är utformade för att samla olika mängder av data så
att delarna blir lätt åtkomliga. Dessa datastrukturer är generella och
deras syfte är att göra det lätt arbeta med data av variabel storlek,
men man kan också se dem som bekväm teknik att indexera eller namnge
delar av data. I ett senare kapitel introducerar vi <em>tupler</em>
(kapitel 6) samt begreppen <em>klass</em> och <em>objekt</em> som ger
oss ett sätt att skapa egna datastrukturer. Klasser används gärna för
att göra program mer lättlästa.</p>
<div id="representera-abstraktioner" class="section level3"
number="5.3.1">
<h3><span class="header-section-number">5.3.1</span> Representera
abstraktioner</h3>
<p>De flesta uppfattar det nog inte som så konstigt att begrepp som
<em>namn</em>, <em>adress</em>, och <em>text</em> är lämpliga att lagra
som strängar. Det kan däremot vara svårare att se hur mer abstrakta
begrepp ska representeras.</p>
<p>Som ett första exempel på abstraktioner kan vi ta punkter i planet.
Vi kan vilja lagra positioner på en karta, punkter i en figur, eller
liknande, och behöver ett sätt att arbeta med positionernas koordinater.
Man kan tänka sig att införa två variabler per punkt, som <code>x</code>
och <code>y</code> och sätta <code>x=0</code> och <code>y=0</code> för
origo, eller använda två listor <code>x</code> och <code>y</code> om man
har många punkter, så origo kanske råkar hamna i första elementen:
<code>x[0]=0</code> och <code>y[0]=0</code>. Nackdelen med detta sätt
att arbeta är att de två koordinater som behöver hanteras ihop ligger
åtskilt, i de två variablerna <code>x</code> och <code>y</code>. Det kan
ibland vara opraktiskt, men framförallt kan det också öka risken för att
man gör fel.</p>
<p>Ett alternativ kan vara att låta koordinater lagras som par, eller
snarare som listor med två element. Vi kan då exempelvis definiera
<code>origin = [0, 0]</code> eller
<code>points = [[0,0], [1,0], [2,1]]</code> och få värden grupperade på
ett naturligt sätt. Det gör det lätt att göra enkla operationer. En
tilldelning kan till exempel se ut som
<code>origin = points[0]</code>.</p>
<p>Ett annat alternativ är att använda en uppslagstabell för punkter och
initiera <code>origin = {'x': 0, 'y': 0}</code>. På det här viset kan vi
alltså namnge elementen och det blir kanske lite lättare att läsa vad
man avser i programmet. Vi skulle till exempel kunna skriva
<code>p['x'] = p['x'] + delta</code> för att justera <span
class="math inline">\(x\)</span>-koordinaten något, och det skulle nog
vara mer lättförståeligt än motsvarande <code>p[0] = p[0] + delta</code>
om vi använder listor för punkter.</p>
<p>Det vi diskuterar här är hur punkter i planet <em>representeras</em>.
Vi tar ett mycket abstrakt begrepp (punkter), funderar på vilka data man
behöver arbeta med (<span class="math inline">\(x\)</span> och <span
class="math inline">\(y\)</span>), och bestämmer hur vi kan använda
enkla datastrukturer för den faktiska lagringen.</p>
</div>
</div>
<div id="exempel-personnummer" class="section level2" number="5.4">
<h2><span class="header-section-number">5.4</span> Exempel:
personnummer</h2>
<p>I många IT-system i det offentliga behöver man arbeta med
personnummer. Hur representerar dem bäst? Eftersom man kan skriva ett
personnummer med 10 eller 12 siffror så kan man överväga att betrakta
dem som heltal. Personnumret 890201-3286 (fiktivt) skulle då bli
8902013286, vilket är ett så pass stort heltal att det inte kan
representeras med ett 32-bitars heltal. Det hanterar Python utan
problem, men i de flesta andra programmeringsspråk blir det ett problem.
En lösning är då att dela upp talet i två delar och skriva
<code>[890201, 3286]</code>. Nu kommer båda talen få plats i ett
32-bitars heltal, men man kommer upptäcka att det kan bli problem med
personer födda på 00-talet. Vi kommer visserligen att kunna jämföra
personnummer utan problem, men vid utskrifter så kommer det bli
missförstånd eftersom vi människor förväntar oss personnummer som just
10- eller 12-ställiga koder.</p>
<p>Nu är det läge att ta ett steg tillbaka och fundera på vad vi kan
vilja göra med personummer. I de flesta fall vill vi bara jämföra dem
(“är det här rätt person?”) och det är knappast viktigt att göra
aritmetiska operationer på dem. Alltså är det inte någon vinst att lagra
personnummer som heltal. Undantaget är om man vill verifiera att ett
personnummer är korrekt inmatat, men då är det ändå de enskilda
siffrorna som man använder för verifikation. Vi kanske vill försäkra oss
om att datumdelen av personnumret är just ett korrekt datum? Många
programmeringsspråk har bra stöd för att lagra och arbeta med just datum
och har särskilda typer för det. (I kapitel 7 introducerar vi
<em>moduler</em>, och Python har man modulen <code>datetime</code> som
är användbar för att arbeta med datum.) Har man erfarenhet av
personnummer drar man sig dock snart till minnes att Skatteverket
använder “samordningsnummer” för personer som inte är folkbokförda i
Sverige. Samordningsnummer ska vara kompatibla med personnummer, men
ändå vara lätt åtskiljbara. Därför har man valt att låta födelsedatum
vara grunden även för samordningsnummer, men man adderar 60 till
födelsedatumet. Om vi konverterar vårt exempelpersonnummer 890201-3286
till ett samordningsdatum så skulle det skriva som 890261-3286. Ett
sådant födelsedatum blir inte möjligt att representera med en vanlig
datumtyp.</p>
<p>Kanske är det enklaste att låta personnummer representeras av
strängar?</p>
</div>
<div id="exempel-polynom" class="section level2" number="5.5">
<h2><span class="header-section-number">5.5</span> Exempel: polynom</h2>
<p>Om man arbetar med polynom (vilket inte bara matematiker kan behöva
göra) så behöver man en representation för dem. Det är inte praktiskt
att lagra <span class="math inline">\(4x^2-3x+7\)</span> som en sträng,
för hur ska man då göra beräkningar på det? Ett vanligt sätt att arbeta
med polynom är att lagra polynomets koefficienter som tal i en lista,
och det mest praktiska är att låta koefficienten för termen med grad
<span class="math inline">\(i\)</span> vara på plats <span
class="math inline">\(i\)</span> i listan. Det kan kännas som baklänges,
men fördelen är att längden på listan motsvarar precis polynomets grad.
Dessutom finns det algoritmiska fördelar.</p>
<p>Några exempel gör det tydligare:</p>
<table>
<thead>
<tr class="header">
<th>Polynom</th>
<th>Python-representation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(3x^2-2x+1\)</span></td>
<td><code>[1, -2, 3]</code></td>
</tr>
<tr class="even">
<td><span class="math inline">\(x^4\)</span></td>
<td><code>[0, 0, 0, 0, 1]</code></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(4x^2 + 5x^3\)</span></td>
<td><code>[0, 0, 4, 5]</code></td>
</tr>
<tr class="even">
<td><span class="math inline">\(5 + 4x + 3x^2 + 2x^3 + x^4\)</span></td>
<td><code>[5, 4, 3, 2, 1]</code></td>
</tr>
</tbody>
</table>
<p>En matematiker kan bli orolig för hur vi representerar
noll-polynomet. Är det som <code>[]</code> eller <code>[0]</code>? Det
är ett specialfall som man kan behöva hantera, till exempel vi beräkning
av ett polynoms gradtal, men det är en detalj som vi inte fördjupar oss
i här.</p>
<p>Med representation av polynom som koefficientlistor har vi möjlighet
att göra olika operationer. Att addera två polynom kommer att hanteras
genom att addera elementen i två koefficientlistor, med viss hänsyn till
att polynomen kan ha olika gradtal.</p>
<p>Som exempel kan vi titta på derivering av polynom. Vi vill kunna
derivera <em>symboliskt</em>, utan att beräkna derivatan i en viss
punkt, så resultatet ska bli ett nytt polynom. Hur lärde vi oss i
skolan? Jo, vi har lärt oss att konstanttermen försvinner, en term <span
class="math inline">\(ax^b\)</span> deriveras till <span
class="math inline">\(abx^{b-1}\)</span>, och varje term kan deriveras
för sig. Vi kan alltså iterera igenom en koefficientlista, hålla reda på
graden på termen som koefficienten representerar, och beräkna nya
koefficienter som <span class="math inline">\(ab\)</span>. En enkel
algoritmidé för att symboliskt derivera ett polynom <span
class="math inline">\(p\)</span> givet som en koefficientlista:</p>
<ul>
<li>Skippa koefficienten på index 0.</li>
<li>Håll reda på aktuellt gradtal.</li>
<li>Lägg de nya koefficienterna i en ny lista.</li>
<li>Iterera över koefficienterna från index 1 och beräkna de nya
koefficienterna.</li>
</ul>
Vi kan formulera Python-kod nästan direkt från denna algoritmidé:
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6ImRlZiBkZXJpdmF0aXZlKHBvbHlub21pYWwpOlxuICAgIHJlc3VsdCA9IFtdXG4gICAgZGVncmVlID0gMVxuICAgIGZvciB0ZXJtIGluIHBvbHlub21pYWxbMTpdOlxuICAgICAgICBuZXdfY29lZmZpY2llbnQgPSB0ZXJtICogZGVncmVlXG4gICAgICAgIHJlc3VsdC5hcHBlbmQobmV3X2NvZWZmaWNpZW50KVxuICAgICAgICBkZWdyZWUgKz0gMVxuICAgIHJldHVybiByZXN1bHQifQ==
</div>
Om man testar funktionen så kan det se ut så här:
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6ImRlcml2YXRpdmUoWzEsIC0yLCAzXSkifQ==
</div>
<pre class="python"><code>[-2, 6]</code></pre>
<p>Det innebär alltså att vi har gått från ett abstrakt polynom till en
konkret symbolisk representation, deriverat “maskinellt” till ny
koefficientlista, som representerar ett annat abstrakt polynom:</p>
<p><span class="math inline">\(3x^2 - 2x + 1\)</span> <span
class="math inline">\(\longrightarrow\)</span> <code>[1, -2, 3]</code>
<span class="math inline">\(\longrightarrow\)</span>
<code>[-2, 6]</code> <span
class="math inline">\(\longrightarrow\)</span> <span
class="math inline">\(6x-2\)</span></p>
<p>Vi kan konstatera att med rätt representation kan vi gör avancerade
beräkningar på abstrakta begrepp.</p>
</div>
</div>
<div id="uppgifter" class="section level1" number="6">
<h1><span class="header-section-number">6</span> Uppgifter</h1>
<ol style="list-style-type: decimal">
<li><p>Givet de två listorna nedan </p>
<pre class="python"><code>a = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]
b = [1, 2, 3]</code></pre>
<p>skapa en uppslagstabell <code
class="python">{'a': 1 ,'b': 2,'c': 3}</code> genom en loop.</p>
<p><em>Tips</em>: Det finns flera sätt att åstakomma detta. Ett sätt är
att använda <code class="python">range</code> för att få ett index som
ni sedan kan använda för att hämta ut element i <code
class="python">a</code> och <code class="python">b</code> med.</p></li>
<li><p>Skriv kod som tar alla par <code>(x,y)</code> av tal mellan
<code>2</code> och <code>20</code> med <code
class="python">x != y</code> och skriver ut deras gemensamma delare
(GCD). </p>
<p><em>Tips 1</em>: Använd nästlade loopar och range.</p>
<p><em>Tips 2</em>: Använd funktionen <code>GCD</code> från förra
kapitlet.</p>
<p>Koden ska till exempel skriva ut följande:</p>
<pre class="python"><code>x y GCD
2 3 1
2 4 2
2 5 1
2 6 2
2 7 1
2 8 2
# osv...</code></pre></li>
<li><p>Gör hela pannkaksreceptet i mer algoritmiskt!</p></li>
<li><p>I den här kursen använder vi funktioner för att strukturera
koden. Vilka funktioner kan du definiera så att pannkaksreceptet i blir
lättare att läsa?</p></li>
<li><p>Skriv ner en algoritm för att addera två heltal givna som två
listor med siffror. Du kan ju addera stora tal med papper och penna, men
hur kan algoritmen beskrivas i text? Kan du skriva kod för algoritmen?
Denna uppgift är svårare än det låter!</p></li>
<li><p>I är det onödigt att skriva ut GCD för till exempel
<code>x,y = 2,3</code> och <code>x,y = 3,2</code>. Gör om koden så att
<code>x</code> alltid är mindre än <code>y</code> i raderna som skrivs
ut.</p>
<p><em>Tips</em>: I den inre <code class="python">for</code> loopen, vad
händer om man itererar från nuvarande värde på <code>x</code>?</p></li>
<li><p>I kapitel 3 jobbade vi med funktionen <code
class="python">vowels</code>. Använd en uppslagstabell som har vokalerna
i <code>vs</code> som nycklar och ett tal som värde (du kan hitta på
talen själv). Modifiera funktionen så att den istället byter ut
vokalerna mot talen.</p></li>
<li><p>I kapitel 3 jobbade vi med funktionen <code>split</code> (given
nedan). Ha strukturen i denna kod som hjälp för att skriva en funktion
<code>annotate_word</code> som tar en sträng och associerar varje ord
med ett tal där talet representerar när ordet sist förekom i texten
(räknat från <code>1</code>). Funktionen ska returnera en uppslagstabell
med ord som nycklar och tal som värden. </p>
<pre class="python"><code>def split(s):
    out = []
    term = &#39;&#39;
    for c in s:
        if c == &#39; &#39;:
            out.append(term)
            term = &#39;&#39;
        else:
            term += c

    # add the final word unless it is empty
    if term != &#39;&#39;:
        out.append(term)

    return out</code></pre>
<p>Funktionen ska funka så här:</p>
<pre class="python"><code>print(annotate_word(&#39;hej du hej hej du&#39;))</code></pre>
<pre class="python"><code>{&#39;hej&#39;: 4, &#39;du&#39;: 5}</code></pre></li>
<li><p>Hur kan vi enkelt få <code>annotate_word</code> i att istället
returnera en uppslagstabell med tal som nycklar och ord som
värden?</p></li>
<li><p>Modifiera <code>annotate_word</code> i så att inte bara sista
förekomsten sparas i texten, utan alla förekomster. Vilken datastruktur
bör vi ha som <em>värde</em> i vår uppslagstabell?</p></li>
</ol>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = false;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
