<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />



<meta name="date" content="2024-06-17" />

<title>Kapitel 6</title>

<script src="site_libs/header-attrs-2.27/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/flatly.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}

.tocify-subheader {
  display: inline;
}
.tocify-subheader .tocify-item {
  font-size: 0.95em;
}

</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">DA2004 Programmersteknik</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Förord</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Kapitel
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="kapitel1.html">1: Kom igång med Python</a>
    </li>
    <li>
      <a href="kapitel2.html">2: Grunder i Python-programmering</a>
    </li>
    <li>
      <a href="kapitel3.html">3: Listor och iteration</a>
    </li>
    <li>
      <a href="kapitel4.html">4: Uppslagstabeller, filhantering och mer om loopar</a>
    </li>
    <li>
      <a href="kapitel5.html">5: Felhantering, särfall, listomfattning och felsökning</a>
    </li>
    <li>
      <a href="kapitel6.html">6: Sekvenser och generatorer</a>
    </li>
    <li>
      <a href="kapitel7.html">7: Moduler, bibliotek och programstruktur</a>
    </li>
    <li>
      <a href="kapitel8.html">8: Funktionell programmering</a>
    </li>
    <li>
      <a href="kapitel9.html">9: Objektorientering 1: Klasser</a>
    </li>
    <li>
      <a href="kapitel10.html">10: Objektorientering 2: Arv</a>
    </li>
    <li>
      <a href="kapitel11.html">11: Objektorientering 3: Mer om arv</a>
    </li>
    <li>
      <a href="kapitel12.html">12: Defensiv programmering</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="appendix.html">Exempellösningar</a>
</li>
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Kapitel 6</h1>
<h4 class="date">2024-06-17</h4>

</div>


<script src="https://cdn.datacamp.com/datacamp-light-latest.min.js"></script>
<div id="kap6:sekvenser" class="section level1" number="1">
<h1><span class="header-section-number">1</span> Sekvenser</h1>
<p>Python har stöd för ett antal olika sekvenstyper. Sekvenstyper i
Python har gemensamt några vanliga operationer, t.ex. gäller:</p>
<ul>
<li><code class="python">+</code>: konkatenering/sammanslagning</li>
<li><code class="python">*</code>: repetition</li>
<li><code class="python">in</code> och <code
class="python">not in</code>: test om ett värde finns/inte finns som
element i sekvensen</li>
<li><code>len()</code>: längden av sekvensen/hur många element</li>
<li><code>min()</code> och <code>max()</code>: minimum och maximum av
element (om element-typerna är kompatibla med <code>&lt;</code> och
<code>&gt;</code>)</li>
<li><code>[:]</code>: slicing för åtkomst av element</li>
<li>m.fl.</li>
</ul>
<p>Många av operationerna ovan känns förmodligen igen från
<code>list</code>. Mycket riktigt är listor en av sekvenstyperna i
Python. De andra typerna vi kommer att titta på i detta kapitel är
tupler, <code>range</code> och strängar, vilka vi alla stött på tidigare
i ett fall eller annat.</p>
<p>Sekvenstyper kan delas in i två underkategorier: <em>muterbara</em>
och <em>icke-muterbara</em>. Med muterbarhet så menas att ett skapat
objekt kan <em>ändras</em> på efter att det skapats. På samma sätt så är
icke-muterbara objekt konstanta. Hur ett objekt används, och vilka
potentiella sidoeffekter kod kan ha, kan bero på om ett objekt är
muterbart eller inte.</p>
<p>För mer detaljerad information, se Python-dokumentationen om <a
href="https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range">sekvenstyper</a>.</p>
<div id="kap6:listor" class="section level2" number="1.1">
<h2><span class="header-section-number">1.1</span> Listor</h2>
<p>Listor är en sekvenstyp som är <em>muterbar</em>. Det är en viktig
egenskap hos listor som betyder att vi kan uppdatera deras värden utan
att kopiera listan. Vi har redan sett många exempel på vad som kan göras
med listor, men för att poängtera vilken effekt det kan ha att listor är
muterbara, betrakta på följande funktionsdefinition och kod:</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6ImRlZiBzdW1fb2ZfaW5jcmVtZW50KGwsIHgpOlxuICAgIGZvciBpIGluIHJhbmdlKGxlbihsKSk6XG4gICAgICAgIGxbaV0gKz0geFxuICAgIHJldF9zdW0gPSBzdW0obClcbiAgICByZXR1cm4gcmV0X3N1bVxuXG5teWxpc3QgPSBbMywgMywgNCwgNV1cbnByaW50KFwibXlsaXN0IGlzOlwiLCBteWxpc3QpXG5zID0gc3VtX29mX2luY3JlbWVudChteWxpc3QsIDIpXG5wcmludChcIm15bGlzdCBhZnRlciBmaXJzdCBjYWxsOlwiLCBteWxpc3QpXG5wcmludChcIkZpcnN0IGNhbGwgcmV0dXJuczpcIiwgcylcbnMgPSBzdW1fb2ZfaW5jcmVtZW50KG15bGlzdCwgMilcbnByaW50KFwibXlsaXN0IGFmdGVyIHNlY29uZCBjYWxsOlwiLCBteWxpc3QpXG5wcmludChcIlNlY29uZCBjYWxsIHJldHVybnM6XCIsIHMpIn0=
</div>
<pre class="python"><code>mylist is: [3, 3, 4, 5]
mylist after first call: [5, 5, 6, 7]
First call returns: 23
mylist after second call: [7, 7, 8, 9]
Second call returns: 31</code></pre>
<p>Resultatet blir olika varje gång funktionen kallas, även om
funktionsanropet görs med samma variabler! Det här beror på att
<code>mylist</code> ändras inuti funktionen, vilket går att göra
eftersom listor är muterbara. Det här är också möjligt för att Python
inte kopierar hela listan till funktionsargumentet (i det här fallet
<code>l</code>). Detta kan ibland vara användbart, men man bör vara
medveten om och försiktig med detta, så att det inte får oanade
konsekvenser.</p>
<p>För mer om listor och vilka funktioner som <code>list</code>-typen
har, se Python-dokumentationen och <a
href="https://docs.python.org/3/tutorial/datastructures.html#more-on-lists">mer
info om listor</a>.</p>
</div>
<div id="tupler" class="section level2" number="1.2">
<h2><span class="header-section-number">1.2</span> Tupler</h2>
<p>Tupler liknar listor, men de är <em>icke-muterbara</em>. Så vi kan
inte bara uppdatera en tupel som vi vill. Vi har sett tupler förr, även
om vi kanske inte explicit skapat variabler av typen tupler: <a
href="#multipla-returvärden">multipla returvärden</a> från
<em>funktioner</em> returneras nämligen som en tupel med flera element.
Syntaxen för tupler är väldigt likt den som listor, med den skillnaden
är att man använder <code>()</code> för att skapa en tupel istället för
<code>[]</code>.</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6Im15dHVwbGUgPSAoMywgMywgNCwgNSlcbm15b3RoZXJ0dXBsZSA9IDMsIDMsIDQsIDUgIyBlcXVpdmFsZW50IHN5bnRheFxucHJpbnQobXl0dXBsZSlcbnByaW50KG15dHVwbGUgPT0gbXlvdGhlcnR1cGxlKVxucHJpbnQobXl0dXBsZVswXSlcbnByaW50KG15dHVwbGVbMzoxOi0xXSlcbnByaW50KGxlbihteXR1cGxlKSlcbnByaW50KDMgaW4gbXl0dXBsZSlcblxuIyBmdW5jdGlvbiByZXR1cm5pbmcgbXVsdGlwbGUgdmFsdWVzXG5kZWYgaW50ZWdlcl9kaXYobm9taW5hdG9yLCBkZW5vbWluYXRvcik6XG4gICAgcSA9IG5vbWluYXRvciAvLyBkZW5vbWluYXRvclxuICAgIHIgPSBub21pbmF0b3IgJSBkZW5vbWluYXRvclxuICAgIHJldHVybiBxLCByXG5cbmRpdnMgPSBpbnRlZ2VyX2RpdigxNywgMTApXG5wcmludCh0eXBlKGRpdnMpKVxuXG4jIHR1cGxlcyBhcmUgaW1tdXRhYmxlXG5teXR1cGxlWzBdID0gNDIifQ==
</div>
<pre class="python"><code>(3, 3, 4, 5)
True
3
(5, 4)
4
True
&lt;class &#39;tuple&#39;&gt;
TypeError: &#39;tuple&#39; object does not support item assignment</code></pre>
<p>Lägg märke till att slicing av en tupel ger tillbaka en tupel:
slicing av en sekvenstyp ger tillbaka samma typ.</p>
<p>Om vi t.ex. skulle köra om kodexemplet från sektionen <a
href="#kap6:listor">Listor</a>, med funktionen
<code>sum_of_increment</code> definierad på samma sätt, fast med en
tupel:</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6Im15dHVwbGUgPSAoMywgMywgNCwgNSlcbnMgPSBzdW1fb2ZfaW5jcmVtZW50KG15dHVwbGUsIDIpIn0=
</div>
<pre class="python"><code>TypeError: &#39;tuple&#39; object does not support item assignment</code></pre>
<p>Precis som listor, kan tupler innehålla olika datatyper och vi kan
nästla dem:</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6InQgPSAoMTIzNDUsIDU0MzIxLCAnaGVsbG8hJylcbm15dHVwbGUgPSAodCwgKDEsIDIsIDMsIDQsIDUpKVxucHJpbnQobXl0dXBsZSkifQ==
</div>
<pre class="python"><code>((12345, 54321, &#39;hello!&#39;), (1, 2, 3, 4, 5))</code></pre>
<p>Tupler kan innehålla <em>muterbara</em> objekt:</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6InQyID0gKFsxLCAyLCAzXSwgWzMsIDIsIDFdKVxucHJpbnQodDIpIn0=
</div>
<pre class="python"><code>([1, 2, 3], [3, 2, 1])</code></pre>
<p>Det sista exemplet <code>t2</code>, kan <em>inte</em> användas som
nyckel i en uppslagstabell. Jämför t.ex.:</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6ImQgPSB7dDogJ2hlbGxvJ30gIyB3b3Jrc1xuZDIgPSB7dDI6ICdnb29kYnllJ30gIyBUeXBlRXJyb3I6IHVuaGFzaGFibGUgdHlwZTogJ2xpc3QnIn0=
</div>
<p>Det här är som diskuterats tidigare för att nyckelvärden måste vara
konstanta. I detta fall räcker det alltså inte med att själva tupeln är
icke-muterbar eftersom den innehåller muterbara objekt (listor), vilket
gör att <code>t2</code> <em>inte</em> kan användas som nyckel.</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6IiMgdDJbMF0gPSBbMSwgMiwgNF0gIyB0aHJvd3MgVHlwZUVycm9yLCBpbW11dGFibGVcbnByaW50KHQyKVxudDJbMF1bMF0gPSA0MlxucHJpbnQodDIpIn0=
</div>
<pre class="python"><code>([1, 2, 3], [3, 2, 1])
([42, 2, 3], [3, 2, 1])</code></pre>
</div>
<div id="range" class="section level2" number="1.3">
<h2><span class="header-section-number">1.3</span>
<code>range</code></h2>
<p>Pythons <code>range</code> är också en <em>icke-muterbar</em>
sekvenstyp. Den beter sig som en tupel, men den har inte stöd för vissa
operationer, t.ex. <code>+</code> och <code>*</code>.</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6Im15cmFuZ2UgPSByYW5nZSgxMClcbnByaW50KG15cmFuZ2VbM10pXG5wcmludChteXJhbmdlWzI6OTozXSlcbnByaW50KDQgaW4gbXlyYW5nZSlcbnByaW50KDQyIGluIG15cmFuZ2UpXG5teXJhbmdlICsgbXlyYW5nZSJ9
</div>
<pre class="python"><code>3
range(2, 9, 3)
True
False
TypeError: unsupported operand type(s) for +: &#39;range&#39; and &#39;range&#39;</code></pre>
<p>Återigen, slicing ger här tillbaka en <code>range</code>-typ.</p>
</div>
<div id="strängar" class="section level2" number="1.4">
<h2><span class="header-section-number">1.4</span> Strängar</h2>
<p>Strängar är även de ett exempel på en sekvenstyp, också
<em>icke-muterbara</em>. Vi har precis som listor använt strängar
flitigt. Det finns väldigt många användbara strängfunktioner; de flesta
funktionerna har namn som tydligt säger vad de gör. Här nedan ges bara
några exempel för vanligt förekommande strängfunktioner:</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6Im15X3N0cmluZyA9IFwiSGVsbG8gd29ybGQhIFRoaXMgaXMgZnVuXCJcbnByaW50KG15X3N0cmluZy5pbmRleChcIm9cIikpXG5wcmludChteV9zdHJpbmcuY291bnQoXCJsXCIpKVxucHJpbnQobXlfc3RyaW5nLnVwcGVyKCkpXG5wcmludChteV9zdHJpbmcubG93ZXIoKSlcbnByaW50KG15X3N0cmluZy5jYXBpdGFsaXplKCkpXG5wcmludChteV9zdHJpbmdbMzo3XSlcbnByaW50KG15X3N0cmluZ1szOjc6Ml0pXG5wcmludChteV9zdHJpbmdbOjotMV0pXG5wcmludChteV9zdHJpbmcuc3RhcnRzd2l0aChcIkhlbGxvXCIpKVxucHJpbnQobXlfc3RyaW5nLmVuZHN3aXRoKFwiYXNkZmFzZGZhc2RmXCIpKVxucHJpbnQobXlfc3RyaW5nLnNwbGl0KCkpXG5wcmludChteV9zdHJpbmcuc3BsaXQoXCJpXCIpKSJ9
</div>
<pre class="python"><code>4
3
HELLO WORLD! THIS IS FUN
hello world! this is fun
Hello world! this is fun
lo w
l
nuf si sihT !dlrow olleH
True
False
[&#39;Hello&#39;, &#39;world!&#39;, &#39;This&#39;, &#39;is&#39;, &#39;fun&#39;]
[&#39;Hello world! Th&#39;, &#39;s &#39;, &#39;s fun&#39;]
H</code></pre>
<p>Glöm inte att man in Spyder lätt i t.ex. konsolen kan se vilka
funktioner som är associerade med en sträng (eller generellt ett givet
objekt) genom att använda sig av <code>dir()</code>. T.ex. kan man:</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6ImRpcihteV9zdHJpbmcpIn0=
</div>
<p>Detta kan ge lite “för mycket” information. Vill man ha en mer
interaktivt sätt, kan man i konsolen skriva <code>my_string.</code>
(lägg märke till punkten) och sen trycka <code>TAB</code>.</p>
<p>För mer om strängar och fler strängfunktioner, se <a
href="https://docs.python.org/3/library/stdtypes.html#text-sequence-type-str">Python-dokumentationen</a>.</p>
</div>
</div>
<div id="generatorer" class="section level1" number="2">
<h1><span class="header-section-number">2</span> Generatorer</h1>
<p><em>Generatorer</em> i Python är itererbara objekt som i varje
iteration lämnar tillbaka ett värde till användaren. Vad värdet är beror
på hur en generator har definierats. Vi har stött på flera itererbara
objekt tidigare, t.ex. är alla sekvenstyper som precis beskrivits i <a
href="#kap6:sekvenser">Sekvenser</a> itererbara.</p>
<p>Den största skillnaden mellan generatorer och sekvenstyper (förutom
<code>range</code>) är när själva beräkningen av elementen sker: detta
kan antingen ske <em>direkt</em> när man skapar objektet eller först när
värdet på elementet <em>behövs</em>, d.v.s. när man väl utför en loop.
Generatorer är ett exempel på en typ där värdet av ett element beräknas
först när det behövs, detta är så kallad <em>lat evaluering</em>.</p>
<div id="lat-och-strikt-evaluering" class="section level2" number="2.1">
<h2><span class="header-section-number">2.1</span> Lat och strikt
evaluering</h2>
<p>Om alla värden i ett objekt beräknas när objektet skapas kallar man
det <em>strikt</em> eller <em>ivrig evaluering/beräkning</em> (eng.
<em>eager evaluation</em>). Motsatsen är <em>lat</em> eller <em>selektiv
evaluering</em> (eng. <em>lazy evaluation</em>) där värden beräknas när
de behövs. Ett exempel med sekvenstyper som visar skillnaden:</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6Im15bGlzdCA9IFswLCAxLCAyLCAzLCA0LCA1XVxubXlyYW5nZSA9IHJhbmdlKDYpXG5wcmludChcIm15bGlzdDogXCIsIG15bGlzdClcbnByaW50KFwibXlyYW5nZTogXCIsIG15cmFuZ2UpIn0=
</div>
<pre class="python"><code>mylist:  [0, 1, 2, 3, 4, 5]
myrange:  range(0, 6)</code></pre>
<p>Här har vi skapat en lista <code>mylist</code>, som är ett exempel på
strikt evaluering: alla värden som listan innehåller är här beräknade
och sparade i minnet som utskriften visar. Utskriften av
<code>range</code> å andra sidan visar bara just det, att det är ett
objekt av typen <code>range</code> skapat med inparametrar
<code>0, 6</code>. <code>range</code> är ett exempel på lat evaluering:
alla värden som <code>myrange</code> innehåller <em>beräknas</em> varje
gång man t.ex. gör <code>myrange[0]</code>. Lat evaluering kommer väl
till hands när man använder sig av iteration, då det är mycket mer
<em>minneseffektivt</em> än att iterera över ett objekt som är helt
sparat i minnet.</p>
<p><code>range</code> är lite av ett specialfall jämfört med de andra
sekvenstyperna, just eftersom det är lat evaluering. Den finns för att
det är en så vanlig struktur att ha en sekvens av ökande tal. Om man
vill använda sig av lat evaluering, fast för mer komplicerade
strukturer, så kommer generatorer väl till hands.</p>
</div>
<div id="generatorfunktioner" class="section level2" number="2.2">
<h2><span class="header-section-number">2.2</span>
Generatorfunktioner</h2>
<p>I Python kan man skapa en generatorfunktion på ett väldigt likt sätt
som man skapar en vanlig funktion. När en vanlig funktion anropas, så
exekveras all kod i funktionen fram tills att en
<code>return</code>-sats stöts på, då ett värde (potentiellt) lämnas
tillbaka till användaren och avslutar funktionskörningen. En
generatorfunktion returnerar ett värde med <code
class="python">yield</code>, men funktionens <em>tillstånd sparas</em>.
Nästa gång funktionen anropas så fortsätter funktionen från där den var
sist tills <em>nästa</em> gång en <code class="python">yield</code>-sats
stöts på, vid vilken den lämnar tillbaka värdet och “pausar”.</p>
<p>Vi använder här funktionsanrop för generatorfunktioner lite löst.
Egentligen kallas själva generatorfunktionen endast <em>en gång</em> och
ger då tillbaka en generator. Det är denna generator som när den
itereras över varje gång exekverar koden i generatorfunktionen.</p>
<p>Ett exempel visar nog detta bättre:</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6ImRlZiBpbmZfZ2VuKHN0YXJ0PTAsIHN0ZXBfc2l6ZT0xKTpcbiAgICBcIlwiXCJJbmZpbml0ZWx5IGdlbmVyYXRlIGFzY2VuZGluZyBudW1iZXJzXCJcIlwiXG4gICAgd2hpbGUgVHJ1ZTpcbiAgICAgICAgeWllbGQgc3RhcnRcbiAgICAgICAgc3RhcnQgKz0gc3RlcF9zaXplIn0=
</div>
<p>Detta är en oändlig uppräkning av tal: en “oändlig
<code>range</code>”. Hade vi försökt att använda oss av en lista, så
inser man snabbt att det är svårt att skapa ett objekt med
<em>oändligt</em> många element: vi hade fått slut på minne på datorn.
Men representeras det som en generator är detta inget problem och vi kan
fortfarande iterera över den. För att komma åt underliggande generator
som man kan iterera över anropar man generatorfunktionen:</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6Im15X2luZl9nZW4gPSBpbmZfZ2VuKDEwLCAxKVxucHJpbnQobXlfaW5mX2dlbilcbnByaW50KG5leHQobXlfaW5mX2dlbikpXG5wcmludChuZXh0KG15X2luZl9nZW4pKVxucHJpbnQobmV4dChteV9pbmZfZ2VuKSkifQ==
</div>
<pre class="python"><code>&lt;generator object inf_gen at 0x7f1d7855be40&gt;
10
11
12</code></pre>
<p>Här har vi använt oss av <code>next</code>-funktionen med generatorn
<code>my_inf_gen</code> som argument för att stega fram nästa värde. Det
är faktiskt implicit <code>next</code> som anropas om man skulle iterera
över <code>my_inf_gen</code> genom att t.ex. göra <code
class="python">for i in my_inf_gen: print(i)</code>. Vi kan inte göra
det här, eftersom det skulle fortsätta i oändlighet, men testa gärna
själv för att se vad som händer. (För att avsluta en oändlig loop kan
man trycka <code>CTRL+c</code>)</p>
<p>Generatorer behöver självklart inte vara oändligt itererbara (som
ovan). Som du ser kan du bestämma själv hur komplicerad en generator ska
bli med nästan samma syntax som för en vanlig funktion. Iterationen över
en generator avslutas när funktionskroppen körs utan att stöta på ett
<code class="python">yield</code>. Precis som man kan ha flera <code
class="python">return</code>-satser i en funktion, kan man ha flera
<code class="python">yield</code> i en generatorfunktion. Skillnaden är
att funktionsblocket fortsätter från där det slutade vid senaste <code
class="python">yield</code>. En viktig detalj, och skillnad mot
<code>range</code>, är att en generator bara kan itereras över <em>en
gång</em>.</p>
<p>Vi illustrerar ovan koncept med en enkel generatorfunktion:</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6ImRlZiBteV9nZW5lcmF0b3Ioc3RvcD01KTpcbiAgICBpID0gMFxuICAgIGogPSAwXG4gICAgd2hpbGUgaSArIGogPCBzdG9wOlxuICAgICAgICBwcmludChcImk6IFwiLCBpLCBcImo6XCIsIGopXG4gICAgICAgIGkgKz0gMVxuICAgICAgICB5aWVsZCBpICsgalxuICAgICAgICBwcmludChcImk6IFwiLCBpLCBcImo6XCIsIGopXG4gICAgICAgIGkgKz0gMVxuICAgICAgICBqICs9IDFcbiAgICAgICAgeWllbGQgaSArIGpcbiAgICAgICAgcHJpbnQoXCJpOiBcIiwgaSwgXCJqOlwiLCBqKVxuXG5pdCA9IDFcbmdlbiA9IG15X2dlbmVyYXRvcigpXG5mb3IgaSBpbiBnZW46XG4gICAgcHJpbnQoXCJJdGVyYXRpb246IFwiLCBpdCwgXCJnZW4gcmV0dXJuczogXCIsIGkpXG4gICAgaXQgKz0gMVxuXG4jIGxvb3AgYSBzZWNvbmQgdGltZVxuZm9yIGkgaW4gZ2VuOlxuICAgIHByaW50KFwiV2lsbCB0aGlzIGJlIHByaW50ZWQ/Pz9cIikifQ==
</div>
<pre class="python"><code>i:  0 j: 0
Iteration:  1 gen returns:  1
i:  1 j: 0
Iteration:  2 gen returns:  3
i:  2 j: 1
i:  2 j: 1
Iteration:  3 gen returns:  4
i:  3 j: 1
Iteration:  4 gen returns:  6
i:  4 j: 2</code></pre>
</div>
<div id="generatoruttryck" class="section level2" number="2.3">
<h2><span class="header-section-number">2.3</span> Generatoruttryck</h2>
<p>Generatorer kan även skrivas på ett liknande sätt som
listomfattningar. Det skapas då ingen lista utan istället får man en
generator som man kan arbeta vidare med, framförallt iterera över med
olika verktyg. Här skapas en lista och en generator.</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6ImJpZ19saXN0ID0gW3gqKjIgZm9yIHggaW4gcmFuZ2UoMTAqKjgpXVxuYmlnX2dlbmVyYXRvciA9ICh4KioyIGZvciB4IGluIHJhbmdlKDEwKio4KSlcbnByaW50KFwiU2l6ZSBvZiBiaWdfbGlzdCBpbiBtZW1vcnk6XCIsIGJpZ19saXN0Ll9fc2l6ZW9mX18oKSlcbnByaW50KFwiU2l6ZSBvZiBiaWdfZ2VuZXJhdG9yIGluIG1lbW9yeTpcIiwgYmlnX2dlbmVyYXRvci5fX3NpemVvZl9fKCkpIn0=
</div>
<pre class="python"><code>Size of big_list in memory: 859724448
Size of big_generator in memory: 96</code></pre>
<p>Som vi ser har listomfattningen genererat hela listan i minnet på
datorn. Detta illustrerar vikten av att använda sig utav generatorer när
vi ska iterera över många värden.</p>
</div>
<div id="kap6:gen_ex" class="section level2" number="2.4">
<h2><span class="header-section-number">2.4</span> Exempel: Generator
för alla primtal</h2>
<p>Generatorer är smidiga att använda till vissa saker, bland annat
oändliga sekvenser.</p>
<p>Låt oss säga att vi vill beräkna alla primtalsdelare till ett tal
<code>x</code>. Vi kan då skapa en generator med alla primtal och se hur
många gånger varje primtal delar <code>x</code>:</p>
<div data-datacamp-exercise="" data-height="300" data-encoded="true">
eyJsYW5ndWFnZSI6InB5dGhvbiIsInNhbXBsZSI6ImRlZiBpc19wcmltZSh4KTpcbiAgICBmb3IgdCBpbiByYW5nZSgyLCB4KTpcbiAgICAgICAgaWYgeCAlIHQgPT0gMDpcbiAgICAgICAgICAgIHJldHVybiBGYWxzZVxuICAgIHJldHVybiBUcnVlXG5cblxuZGVmIHByaW1lX2RpdnMoeCk6XG4gICAgcHJpbWVzID0gKGkgZm9yIGkgaW4gaW5mX2dlbigyKSBpZiBpc19wcmltZShpKSlcbiAgICBwcyA9IFtdXG4gICAgZm9yIHAgaW4gcHJpbWVzOlxuICAgICAgICBpZiBwID4geDpcbiAgICAgICAgICAgIHJldHVybiBwc1xuICAgICAgICBlbHNlOlxuICAgICAgICAgICAgd2hpbGUgeCAlIHAgPT0gMDpcbiAgICAgICAgICAgICAgICBwcy5hcHBlbmQocClcbiAgICAgICAgICAgICAgICB4IC8vPSBwXG5cbnByaW50KHByaW1lX2RpdnMoMikpXG5wcmludChwcmltZV9kaXZzKDMpKVxucHJpbnQocHJpbWVfZGl2cygyNCkpXG5wcmludChwcmltZV9kaXZzKDI1KSlcbnByaW50KHByaW1lX2RpdnMoMjMyKSkifQ==
</div>
<pre class="python"><code>[2]
[3]
[2, 2, 2, 3]
[5, 5]
[2, 2, 2, 29]</code></pre>
</div>
</div>
<div id="kap6:uppgifter" class="section level1" number="3">
<h1><span class="header-section-number">3</span> Uppgifter</h1>
<ol style="list-style-type: decimal">
<li><p>Vi såg att funktionen <code>sum_of_increment(l, x)</code> ändrade
i vår lista när vi kallade på den flera gånger. Vi såg även att vi inte
kunde kalla på <code>sum_of_increment(l, x)</code> med en tupel. Kan du
av detta dra slutsats när det kan vara bra att använda sig av
tupler?</p></li>
<li><p>Skriv en funktion <code>is_palindrome</code> som tar en sträng
som input, och returnerar <code class="python">True</code> om strängen
är ett palindrom (d.v.s. om det är samma sak framlänges som baklänges)
och returnerar den omvända strängen om det inte är ett palindrom.</p>
<p><em>Tips</em>: använd sträng-slicing.</p></li>
</ol>
<!-- 2.  Skriv en funktion `is_palindrome` som tar ett heltal som input,
    och returnerar `True` om talet är ett palindrom (dvs om det är
    samma sak framlänges som baklänges) och returnerar det omvända
    talet om det inte är ett palindrom.

    _Tips_: För att stega sig igenom heltalet brukar man vanligtvis
    använda sig av heltalsdivision med 10, och spara resten i en
    temporär variabel. Men här kan du utnyttja att Pythons möjlighet
    att explicit typomvandla till en sekvenstyp som är lätt att
    indexera/slicea för att underlätta att undersöka om talet är ett
    palindrom. -->
<ol start="3" style="list-style-type: decimal">
<li><p>Fungerar <code>is_palindrome</code> som du skrev i uppgift 2 för
listor och tupler? Varför?</p></li>
<li><p>Skriv en funktion <code>occurrences</code> som beräknar hur många
gånger bokstäver förekommer i en sträng. Funktionen ska returnera en
uppslagstabell med bokstäverna som nycklar och antal gånger bokstäverna
förekommer i strängen. Funktionen ska inte göra skillnad på versaler och
gemener, utan räkna dessa gemensamt (för en given bokstav). Alla tecken
som <em>inte</em> är bokstäver ska räknas under nyckeln
<code>'non_alphas'</code>, och tecken som <em>inte</em> finns med i
strängen ska inte finnas med i uppslagstabellen.</p>
<p><em>Tips</em>: använd dig av de inbyggda strängfunktionerna. Se till
exempel Python-dokumentation för <a
href="https://docs.python.org/3/library/stdtypes.html#string-methods">strängfunktioner</a></p>
<p>Exempel:</p>
<pre class="python"><code>s = &#39;Hello my very happy friend! Is the sun shining?!&#39;
uo = occurrences(s)
print(s)
for k, v in uo.items():
    print(k, &quot;:&quot;, v)

s = &#39;JjJJJjj hHhh !/:;(+[//=--*])&#39;
uo = occurrences(s)
print(&quot;\n&quot; + s)
for k, v in uo.items():
    print(k, &quot;:&quot;, v)
</code></pre>
<pre class="python"><code>Hello my very happy friend! Is the sun shining?!
h : 4
e : 4
l : 2
o : 1
non_alphas : 11
m : 1
y : 3
v : 1
r : 2
a : 1
p : 2
f : 1
i : 4
n : 4
d : 1
s : 3
t : 1
u : 1
g : 1

JjJJJjj hHhh !/:;(+[//=--*])
j : 7
non_alphas : 17
h : 4</code></pre></li>
<li><p>Använd <code>occurrences(s)</code> ovan för att skriva ett
program som läser in en fil och skriver ut bokstäverna som nycklar och
antalet gånger bokstäverna förekommer för hela filen. För att testa kan
ni använda filen <code>palindrome.txt</code> med innehåll:</p>
<pre><code>not palindrome line
palindrome line enil emordnilap
no way
hello ! olleh
Tomorrow will be a glorious day!!!
ooooooooooooooooooooooooooo
rust is also a programming language
ooooooooooooioooooooooooo</code></pre>
<p><em>Tips</em>: läs in hela filinnehållet som en sträng.</p></li>
<li><p>Skriv en generatorfunktion <code>fibonacci(stop=x)</code> som
genererar Fibonacci tal (se <a
href="https://sv.wikipedia.org/wiki/Fibonaccital"
class="uri">https://sv.wikipedia.org/wiki/Fibonaccital</a>) mindre eller
lika med <code>x</code>. </p>
<p><em>Tips</em>: Använd dig utav strukturen i funktionen
<code>my_generator</code> ovan.</p></li>
<li><p>I första raden i funktionen <code>prime_divs</code> i <a
href="#kap6:gen_ex">Exempel: generator för alla primtal</a> så använde
vi oss av ett generatoruttryck för att “filtrera” alla tal ur en
generator som var primtal i en ny generator. Man kan för sin
filter-generator alltså skriva:</p>
<pre class="python"><code>filter_gen = (i for i in iterable if function(i))</code></pre>
<p>Här är <code>function</code> en (användardefinierad) funktion som ger
tillbaka <code class="python">True</code> eller <code
class="python">False</code> när <code>i</code> ges som argument, och
<code>iterable</code> är ett itererbart objekt (t.ex. en generator som
vi hade i <code>prime_divs</code>). Alla <code>i</code> som ger
<code>function(i) == True</code> kommer vara en del av
<code>filter_gen</code>. Python har redan implementerat detta i
funktionen <code>filter</code>, som du kan läsa dokumentationen om. En
liknande funktion är <code>map</code> (se dokumentationen) där
generatorn som skapas bör innehålla <em>värdena</em> som en funktion
<code>f</code> <em>returnerar</em> när <code>f</code> appliceras på alla
element i ett itererbart objekt.</p>
<p>Skriv en egen funktion <code>map_gen</code> som åstadkommer detta
genom att ta en <em>godtycklig</em> <strong>funktion</strong> som
argument och ett itererbart objekt, och som <em>returnerar</em> en
generator. </p>
<p>Exempel: </p>
<pre class="python"><code>gen = map_gen(int, &#39;123456&#39;)
sum(gen)</code></pre>
<pre class="python"><code>21</code></pre></li>
<li><p>Skriv en funktion <code>palindrome_rows</code> som tar ett
filnamn som argument, och kollar varje rad i filen om det är ett
palindrom eller inte. <code>palindrome_rows</code> ska resultera i en
generator som man kan iterera över när funktionen anropas.</p>
<p><em>Tips</em>: tänk på att rader läses in <em>inklusive</em>
ny-rad-tecken. Modifiera <code>is_palindrome</code> från uppgift 2 så
att den bara lämnar tillbaka <code class="python">True</code> eller
<code class="python">False</code> baserat på om strängen är ett
palindrom (alltså inte lämnar tillbaka själva strängen baklänges om det
<em>inte</em> är ett palindrom).</p>
<p>Exempel med filen <code>palindrome.txt</code> ovan:</p>
<pre class="python"><code>p_rows = palindrome_rows(&#39;palindrome.txt&#39;)
i = 1
for p in p_rows:
    print(&quot;Row&quot;, i, &quot;palindrome?&quot;, p)
    i += 1</code></pre>
<pre class="python"><code>Row 1 palindrome? False
Row 2 palindrome? True
Row 3 palindrome? False
Row 4 palindrome? True
Row 5 palindrome? False
Row 6 palindrome? True
Row 7 palindrome? False
Row 8 palindrome? True</code></pre></li>
<li><p>Du “vet” att det i en fil <code>almost_lowercase.txt</code> som
ska bestå av endast gemener och tecken gömmer sig <em>ett enda</em>
versalt ord, men du vet inte vilket det är. Det här tycker du är extremt
jobbigt! Använd dig av <code>open</code> tillsammans med
strängfunktioner för att <em>utan en loop</em> ta reda på vilket ord det
är. Du kan anta att ett “ord” avgränsas av mellanrum och att alla övriga
ord (utöver det du letar efter) består endast av gemener och/eller
tecken.</p>
<p><em>Tips</em>: någon av <code>strip</code>-funktionerna tillsammans
med indexering kan komma till användning här.</p>
<p><em>Exempel</em> på <code>almost_lowercase.txt</code>:</p>
<pre><code>this is a file that /should/ consist of only lowercase letters.
but it doesn&#39;t!
there is a hidden upppercase word right HERE that you are supposed to find.</code></pre></li>
</ol>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = false;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
